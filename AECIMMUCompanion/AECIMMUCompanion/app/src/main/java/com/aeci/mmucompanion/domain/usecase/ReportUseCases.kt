package com.aeci.mmucompanion.domain.usecase

import com.aeci.mmucompanion.domain.model.*
import com.aeci.mmucompanion.domain.repository.ReportRepository
import com.aeci.mmucompanion.domain.repository.FormRepository
import java.io.File
import javax.inject.Inject

class GetReportHistoryUseCase @Inject constructor(
    private val reportRepository: ReportRepository
) {
    suspend operator fun invoke(
        page: Int = 1,
        limit: Int = 10,
        filter: ReportFilter? = null
    ): Result<ReportHistory> {
        return reportRepository.getReportHistory(page, limit, filter)
    }
}

class GenerateReportUseCase @Inject constructor(
    private val reportRepository: ReportRepository
) {
    suspend operator fun invoke(
        request: ReportGenerationRequest
    ): Result<ReportGenerationResult> {
        return reportRepository.generateReport(request)
    }
}

class DownloadReportUseCase @Inject constructor(
    private val reportRepository: ReportRepository
) {
    suspend operator fun invoke(
        reportId: String,
        localFilePath: String? = null
    ): Result<File> {
        return reportRepository.downloadReport(reportId, localFilePath)
    }
}

class DeleteReportUseCase @Inject constructor(
    private val reportRepository: ReportRepository
) {
    suspend operator fun invoke(reportId: String): Result<Unit> {
        return reportRepository.deleteReport(reportId)
    }
}

class GetReportStatisticsUseCase @Inject constructor(
    private val reportRepository: ReportRepository
) {
    suspend operator fun invoke(): Result<ReportStatistics> {
        return reportRepository.getReportStatistics()
    }
}

class SearchReportsUseCase @Inject constructor(
    private val reportRepository: ReportRepository
) {
    suspend operator fun invoke(
        query: String,
        page: Int = 1,
        limit: Int = 10
    ): Result<ReportHistory> {
        return reportRepository.searchReports(query, page, limit)
    }
}

class TrackFormCompletionUseCase @Inject constructor(
    private val formRepository: FormRepository,
    private val reportRepository: ReportRepository
) {
    suspend operator fun invoke(
        formId: String,
        userId: String,
        completionDate: java.time.LocalDateTime = java.time.LocalDateTime.now()
    ): Result<Unit> {
        return try {
            // Mark Form as completed
            // Note: FormRepository doesn't have updateFormStatus, so we'll handle completion differently
            try {
                // Optionally trigger report generation for specific form types
                val form = formRepository.getFormById(formId)
                if (form != null && shouldTriggerReport(form)) {
                    // TODO: Implement generateAutomaticReport function
                    // generateAutomaticReport(form, userId)
                }
                Result.success(Unit)
            } catch (e: Exception) {
                Result.failure(e)
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private fun shouldTriggerReport(form: Form): Boolean {
        return when (form.formType) {
            FormType.MMU_DAILY_LOG,
            FormType.MMU_QUALITY_REPORT,
            FormType.PUMP_90_DAY_INSPECTION -> true
            else -> false
        }
    }
    
    private suspend fun generateReport(form: Form, userId: String) {
        try {
            val reportType = when (form.formType) {
                FormType.MMU_DAILY_LOG -> ReportType.PRODUCTION_REPORT
                FormType.MMU_QUALITY_REPORT -> ReportType.QUALITY_CONTROL
                FormType.PUMP_90_DAY_INSPECTION -> ReportType.MAINTENANCE_REPORT
                else -> return // No automatic report for this Form type
            }
            
            val request = ReportGenerationRequest(
                reportType = reportType,
                reportTitle = "Auto-generated ${reportType.name} for ${form.formType.name}",
                format = ExportFormat.PDF,
                formIds = listOf(form.id),
                parameters = mapOf(
                    "autoGenerated" to true,
                    "triggerFormId" to form.id,
                    "triggerFormType" to form.formType.name
                )
            )
            
            reportRepository.generateReport(request)
        } catch (e: Exception) {
            // Silently fail automatic report generation
        }
    }
}

class SyncReportsWithServerUseCase @Inject constructor(
    private val reportRepository: ReportRepository
) {
    suspend operator fun invoke(): Result<Unit> {
        return reportRepository.syncReports()
    }
}

class CacheReportForOfflineUseCase @Inject constructor(
    private val reportRepository: ReportRepository
) {
    suspend operator fun invoke(reportId: String): Result<Unit> {
        return reportRepository.cacheReport(reportId)
    }
}

class GetMyReportsUseCase @Inject constructor(
    private val reportRepository: ReportRepository
) {
    suspend operator fun invoke(
        page: Int = 1,
        limit: Int = 10
    ): Result<ReportHistory> {
        return reportRepository.getMyReports(page, limit)
    }
}

class ExportReportsBundleUseCase @Inject constructor(
    private val reportRepository: ReportRepository
) {
    suspend operator fun invoke(
        reportIds: List<String>,
        bundleName: String
    ): Result<File> {
        return reportRepository.exportReportsBundle(reportIds, bundleName)
    }
}

class GetReportsByTypeUseCase @Inject constructor(
    private val reportRepository: ReportRepository
) {
    suspend operator fun invoke(
        reportType: ReportType,
        page: Int = 1,
        limit: Int = 10
    ): Result<ReportHistory> {
        return reportRepository.getReportsByType(reportType, page, limit)
    }
}

class GetReportsByDateRangeUseCase @Inject constructor(
    private val reportRepository: ReportRepository
) {
    suspend operator fun invoke(
        startDate: Long,
        endDate: Long,
        page: Int = 1,
        limit: Int = 10
    ): Result<ReportHistory> {
        return reportRepository.getReportsByDateRange(startDate, endDate, page, limit)
    }
}

// Extension function to determine if a Form should trigger automatic report generation
private fun FormData.shouldTriggerReport(): Boolean {
    return when (this.formType) {
        FormType.MMU_DAILY_LOG,
        FormType.MMU_QUALITY_REPORT,
        FormType.PUMP_90_DAY_INSPECTION -> true
        else -> false
    }
} 


